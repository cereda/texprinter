/******************************************************************************
 * Copyright 2012-2018 Paulo Roberto Massa Cereda and Ben Frank               *
 *                                                                            *
 * Redistribution and use in source and binary forms, with or                 *
 *  without modification, are permitted provided that the following           *
 *  conditions are met:                                                       *
 *                                                                            *
 * 1. Redistributions of source code must retain the above copyright          *
 * notice, this list of conditions and the following disclaimer.              *
 *                                                                            *
 * 2. Redistributions in binary form must reproduce the above copyright       *
 * notice, this list of conditions and the following disclaimer in the        *
 * documentation and/or other materials provided with the distribution.       *
 *                                                                            *
 * 3. Neither the name of the copyright holder nor the names of it            *
 *  contributors may be used to endorse or promote products derived           *
 *  from this software without specific prior written permission.             *
 *                                                                            *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       *
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT         *
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS         *
 *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE            *
 *  COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,      *
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,      *
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS     *
 *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND    *
 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR     *
 *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE    *
 *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *
 ******************************************************************************/
package org.islandoftex.texprinter.generators

import org.islandoftex.texprinter.TeXPrinter
import org.islandoftex.texprinter.model.Post
import org.islandoftex.texprinter.model.Question
import org.islandoftex.texprinter.utils.AppUtils
import org.islandoftex.texprinter.utils.Dialogs
import mu.KotlinLogging
import java.io.File
import java.io.FileOutputStream
import java.io.OutputStreamWriter

/**
 * Provides the TeX generation from a Question object.
 *
 * @author Paulo Roberto Massa Cereda
 * @version 2.1
 * @since 1.0
 */
object TeXGenerator {

  // the application logger
  private val logger = KotlinLogging.logger { }

  /**
   * Generates a TeX file from a Question object.
   *
   * @param question The question.
   * @param filename The filename.
   */
  fun generate(question: Question, filename: String) {
    // log message
    logger.info { "Starting TeX generation of $filename" }

    // define the file writer
    try {
      OutputStreamWriter(FileOutputStream(filename), Charsets.UTF_8).use { document ->
        // create a new configuration retriever
        val config = TeXPrinter.config
        // log message
        logger.info { "Creating LaTeX headers." }
        // create the header
        document.write("""
          %================================================
          % Source TeX generated by TeXPrinter (${config.appVersionNumber})
          %================================================
          % Disclaimer: Though I try to guess most of
          % the syntax and the code blocks and set them
          % properly, sometimes the generated code might
          % not compile successfully out of the box. In
          % this case, please fix the errors and recompile
          % your document.
          %================================================

          % document class
          \documentclass{article}

          % packages
          %\usepackage[utf8]{inputenc}
          % uncomment inputenc above if your LaTeX is older than 2018-04
          \usepackage[T1]{fontenc}
          \usepackage{xcolor}
          \usepackage{hyperref}

          % definitions
          \definecolor{bluekeywords}{rgb}{0.13,0.13,1}
          \definecolor{greencomments}{rgb}{0,0.5,0}
          \definecolor{redstrings}{rgb}{0.9,0,0}

          % more packages
          \usepackage{listings}
          \usepackage{graphics,graphicx}

          % listings definition
          \lstset{language=[LaTeX]TeX,
            showspaces=false,
            showtabs=false,
            breaklines=true,
            showstringspaces=false,
            breakatwhitespace=true,
            escapeinside={(*@}{@*)},
            commentstyle=\color{greencomments},
            keywordstyle=\color{bluekeywords},
            stringstyle=\color{redstrings},
            basicstyle=\ttfamily\scriptsize,
            frame=single,
            rulecolor=\color{blue}%
            }
          \lstnewenvironment{TeXPrinterListing}{\lstset{language=[LaTeX]TeX,
            showspaces=false,
            showtabs=false,
            breaklines=true,
            showstringspaces=false,
            breakatwhitespace=true,
            escapeinside={(*@}{@*)},
            commentstyle=\color{greencomments},
            keywordstyle=\color{bluekeywords},
            stringstyle=\color{redstrings},
            basicstyle=\ttfamily\scriptsize,
            frame=single,
            rulecolor=\color{blue}%
            }}{}

          % begin document
          \begin{document}

        """.trimIndent())

        /**
         * Adds the post's comments as enumerate list.
         *
         * @param post The post containing the comments.
         */
        fun addPostComments(post: Post) {
          // if the question has comments
          if (post.comments.isNotEmpty()) {
            // log message
            logger.info { "Adding the post's comments." }
            // write the subsection
            document.write("\\subsection*{This post has " + post.comments.size +
                           (if (post.comments.size == 1) " comment:" else " comments:") + "}\n\n")
            // create an enumeration
            document.write("\\begin{enumerate}\n")
            // for each comment
            post.comments.forEach { postComment ->
              // add it as a list item
              document.write("\\item " + AppUtils.escapeHTMLtoTeX(postComment.text) + " -- \\emph{" +
                             postComment.author + " on " + postComment.date + " (" + postComment.votes +
                             (if (postComment.votes == 1) " vote" else " votes") + ")." + "}\n")
            }
            // close the environment
            document.write("\\end{enumerate}\n\n")
          }
        }

        // log message
        logger.info { "Adding the question title." }
        // create the question title
        document.write("\\title{${question.question.title}}\n")

        // log message
        logger.info { "Adding both asker and reputation." }
        // define author
        document.write("\\author{Asked by ${question.question.user.name} (${question.question.user.reputation})}\n")

        // log message
        logger.info { "Adding the question date." }
        // define date
        document.write("\\date{" + question.question.date + " (" + question.question.votes +
                       (if (question.question.votes == 1) " vote" else " votes") + ")}\n")
        // make title
        document.write("\\maketitle\n\n")

        // log message
        logger.info { "Adding the question text." }
        // create the question section
        document.write("\\section*{The question}\n\n")
        // get the question text
        question.question.xhtml = true
        document.write(AppUtils.escapeHTMLtoTeX(question.question.text) + "\n\n")

        addPostComments(question.question)

        // get answers
        val answersList = question.answers
        // if there are no answers
        if (answersList.isEmpty()) {
          // log message
          logger.info { "This question has no answers." }
          // print message
          document.write("\\section*{Sorry, this question has no answers yet.}\n\n")
        } else {
          // set the answer counter
          var answerCount = 1
          // log message
          logger.info { "Adding answers." }

          // for each answer
          answersList.forEach { answer ->
            // log message
            logger.info { "Adding answer $answerCount." }

            // set the message as empty
            var answerAccepted = ""
            // if the answer is accepted
            if (answer.isAccepted) {
              // set the message
              answerAccepted = " -- Marked as accepted"
            }

            // write the title
            document.write("\\section*{Answer $answerCount}\n\n")
            // increase the counter
            answerCount++

            // add the author info
            document.write("\\emph{Answered by " + answer.user.name + " (" + answer.user.reputation + ") on " +
                           answer.date + answerAccepted + " (" + answer.votes +
                           (if (answer.votes == 1) " vote" else " votes") + ")." + "}\n\n\\vspace{0.3cm}\n\n")

            // write the answer
            answer.xhtml = true
            document.write(AppUtils.escapeHTMLtoTeX(answer.text) + "\n\n")

            // if the answer has comments
            addPostComments(answer)
          }
        }

        // log message
        logger.info { "TeX generation complete, closing $filename." }
        // end document
        document.write("\\end{document}\n")
      }
    } catch (exception: Exception) {
      // log message
      logger.error {
        "A generic error occured while trying to save the TeX file. " +
        "MESSAGE: ${AppUtils.printStackTrace(exception)}"
      }
      // log message
      logger.info { "I will try to remove the remaining TeX file." }

      try {
        // reference problematic file
        val target = File(filename)
        // log message
        logger.info { "Opening problematic file $filename." }

        // check if file exists
        if (target.exists()) {
          // log message
          logger.info { "File exists, trying to delete it." }
          // trying to remove it
          if (target.delete()) {
            // log message
            logger.info { "File $filename was successfully removed." }
          } else {
            // log message
            logger.info { "File $filename could not be removed." }
          }
        }
      } catch (se: SecurityException) {
        // log message
        logger.error {
          "A security exception was raised. " +
          "MESSAGE: ${AppUtils.printStackTrace(se)}"
        }
      }

      // critical error, exit
      Dialogs.showExceptionWindow(exception)
    }
  }
}
